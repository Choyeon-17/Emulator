# **Emulator_study_07**
## Handling graphics and input
### Drawing pixels
디스플레이에 출력을 담당하는 opcode는 0xDXYN입니다. Wikipedia는 다음과 같이 설명하고 있습니다.  
- 너비가 8 픽셀이고 높이가 N 픽셀인 표의 시작 좌표 (VX, VY)부터 2D로 출력합니다. 8개의 픽셀의 각각의 행은 메모리 위치 I로부터 시작하여 비트 코딩된 것으로 판독됩니다.(즉, 하나의 메모리 주소는 8 bits 크기의 메모리를 가지므로 높이가 N일 때 메모리 주소 I부터 N까지 디스플레이에 출력하는데, 이때 한 행인 8 bits만큼이 출력되고 한 bit에 담긴 정보가 0이면 출력하지 않고 1이면 출력합니다.) 이 명령을 실행한 후에는 값이 변하지 않습니다. Emulator_study_06에서 설명한 것처럼, 2D를 출력할 때, 화면 픽셀이 설정 해제가 되면 VF는 1로 설정(범위 외)되고, 그렇지 않으면 0(범위 내)으로 설정됩니다.

opcode에 대한 설명에서 알 수 있듯이 CHIP-8은 실제로 2D를 화면에 출력합니다. 2D를 화면에 출력해야 할 위치(opcode는 X와 Y 좌표를 가져오기 위해 확인해야 하는 V 레지스터를 알려줍니다.)와 행 수(N)를 알려줍니다. 각 2D의 너비는 고정되어 있습니다.(8 bits, 1byte) 각 픽셀의 상태는 비트 XOR 연산을 사용하여 설정됩니다. 즉, 현재 픽셀 상태를 메모리의 현재 값과 비교합니다. 픽셀 값이 메모리의 값과 다른 경우, 비트 값은 1이 됩니다. 즉, 1이 들어왔을 때 어떠한 처리를 해줘야 합니다. 두 값이 모두 일치하면 비트 값은 0이 됩니다.
~~~c++
01000101 ^
11110011 = 
-----------
10110110
~~~
opcode가 0xD003이라고 가정합니다. 즉, (0, 0) 위치에 3행만큼의 2D를 출력합니다. 메모리 위치 I에서 다음 값이 설정되었습니다.
~~~c++
memory[I] = 0x3C;
memory[I + 1] = 0xC3;
memory[I + 2] = 0xFF;
~~~
이 3 bytes의 2D 표현은 각 바이트의 이진 값을 보면 됩니다.
~~~c++
HEX     BIN         Sprite
0x3C    00111100     ****
0xC3    11000011   **    **
0xFF    11111111   ********
~~~
이진 표현을 사용하여 배열(gfx [])을 채워야 합니다. 그러나, XOR 연산자를 사용하여 gfx []의 값을 설정하기 전에, 1에서 0으로 변경된 픽셀이 있는지 확인해야 합니다. 이 경우, carry가 발생한 것이므로 VF 레지스터를 1로 설정해야 합니다. 다음은 opcode 0xDXYN의 구현 예입니다.
~~~c++
case 0xD000:
{
    unsigned short x = V[(opcode & 0x0F00) >> 8];
    unsigned short y = V[(opcode & 0x00F0) >> 4];
    unsigned short height = opcode & 0x000F;
    unsigned short pixel;

    V[0xF] = 0;
    for (int yline = 0; yline < height; yline++)
    {
        pixel = memory[I + yline];
        for (int xline = 0; xline < 8; xline++)
        {
            if ((pixel & (0x80 >> xline)) != 0)
            {
                if(gfx[(x + xline + ((y + yline) * 64))] == 1)
                    V[0xF] = 1;
                gfx[x + xline + ((y + yline) * 64)] ^= 1;
            }
        }
    }

    drawFlag = true;
    pc += 2;
}
break;
~~~
- Line 3-4: 2D의 시작 좌표와 높이를 가져옵니다.
- Line 5: 픽셀 높이
- Line 8: VF 레지스터를 초기화합니다.
- Line 9: 각 행을 반복합니다.
- Line 11: 메모리 주소 I에서 시작하는 메모리로부터 픽셀 값을 가져옵니다.
- Line 12: 각 행의 8 bits만큼을 반복합니다.
- Line 14: 현재 평가된 픽셀이 1로 설정되어 있는지 확인합니다.(0x80 >> xline은 한 번에 한 비트씩 바이트를 스캔합니다.)
- Line 16-17: 디스플레이의 픽셀이 1로 설정되어 있는지 확인합니다. 설정된 경우, VF 레지스터를 설정하여 충돌을 등록해야 합니다.
- Line 18: XOR 연산을 사용하여 픽셀 값을 설정합니다.
- Line 23: gfx[] 배열을 변경했으므로 화면을 업데이트해야 합니다.
- Line 24: 다음 opcode로 가기 위해 프로그램 카운터를 업데이트합니다.
### Input
CHIP-8 시스템은 사용자가 시스템과 상호작용 할 수 있는 간단한 HEX 키패드를 사용합니다. 에뮬레이터의 경우 키 상태를 처리하는 변수에 각 키의 상태를 설정하는 메소드를 구현해야 합니다. 매 사이클마다 키 입력 상태를 확인하고 key[]에 저장해야 합니다.

opcode 0xEX9E 및 0xEXA1은 특정 키를 누르거나 누르지 않았는지 확인하기 때문에, 실제로 저장하는 값은 중요하지 않습니다. opcode 0xFX0A는 키를 누를 때까지만 대기하며, 키를 받으면, 키 상태가 아닌 레지스터에 키 이름을 저장합니다.
~~~c++
case 0xE000:
    switch(opcode & 0x00FF)
    {
        // EX9E: 다음 명령을 건너 뜁니다.
        case 0x009E:
            if (key[V[(opcode & 0x0F00) >> 8]] != 0) // VX에 저장된 키가 눌릴 경우
                pc += 4;
            else
                pc += 2;
        break;
    }
~~~
아래는 원래 키패드 레이아웃의 예입니다. 키 매핑을 구현하는 방법은 중요하지 않으나, 오른쪽과 같은 것을 제안합니다.
~~~
Keypad                   Keyboard
+-+-+-+-+                +-+-+-+-+
|1|2|3|C|                |1|2|3|4|
+-+-+-+-+                +-+-+-+-+
|4|5|6|D|                |Q|W|E|R|
+-+-+-+-+       =>       +-+-+-+-+
|7|8|9|E|                |A|S|D|F|
+-+-+-+-+                +-+-+-+-+
|A|0|B|F|                |Z|X|C|V|
+-+-+-+-+                +-+-+-+-+
~~~