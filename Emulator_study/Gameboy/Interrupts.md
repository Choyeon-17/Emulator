# **Interrupts**
CHIP-8 시스템에 인터럽트가 없었기 때문에, 인터럽트가 무엇인지 그리고 그들의 목적이 무엇인지 설명할 것입니다. 인터럽트는 일반적으로 하드웨어에 특별한 신호가 발생했음을 알리는 하드웨어 신호입니다. CPU는 해당 인터럽트에 응답할 수 있는지 설정을 확인합니다. CPU가 인터럽트에 응답하는 방법은 현재 프로그램 카운터를 스택에 저장한 다음, 적절한 인터럽트를 위해 인터럽트 서비스 루틴 주소로 점프하는 것입니다. 그런 다음, 이 인터럽트 루틴을 계속 수행하여 이전 프로그램 카운터를 다시 로드하고 인터럽트 전에 있던 위치에서 코드를 실행합니다. 이런 이유로 이름이 인터럽트인 것입니다.

게임 보이의 인터럽트 처리 상태와 관련된 두 개의 특수 레지스터가 있습니다. 첫 번째는 메모리 주소 0xFFFF에 있는 인터럽트 활성화 레지스터(IE)입니다. 특정 인터럽트를 활성화 및 비활성화하기 위해 게임에서 작성합니다. 예를 들어, 타이머 오버플로와 같이 인터럽트를 발생시키는 일부 이벤트가 발생할 수 있으나, 이 인터럽트는 해당 비트가 IE에서 활성화된 경우에만 서비스됩니다. 활성화되면 인터럽트가 서비스되나, 활성화되지 않으면 인터럽트가 활성화되거나 게임이 요청을 재설정할 때까지 보류 상태로 유지됩니다. 두 번째 인터럽트 레지스터는 메모리 주소 0xFF0F에 있는 인터럽트 요청 레지스터(IF)입니다. 타이머 오버플로를 다시 예로 들면, 타이머가 오버플로될 때마다 인터럽트 요청 레지스터에서 해당 비트를 설정하여 인터럽트를 요청하여 인터럽트 서비스가 시작되거나 게임이 재설정될 때까지 설정 상태를 유지합니다.

인터럽트 처리에 대해 알아야 할 마지막 사항은 마스터 인터럽트 활성화 스위치입니다. 이것은 게임 메모리의 일부가 아니며, 게임이 설정 및 해제되는 bool입니다. 이 bool이 false로 설정되면 인터럽트가 서비스되지 않습니다. 다음은 인터럽트를 처리하는 데 필요한 기준입니다:
~~~
1. 인터럽트를 중단해야 하는 이벤트가 발생하면 IF(0xFF0F)에서 해당 비트를 설정하여 인터럽트 요청을 해야 합니다.
2. 인터럽트 마스터 활성화 스위치가 true로 설정된 경우에만 인터럽트를 서비스할 수 있습니다.
3. 위의 두 조건이 참이고 서비스 우선 순위가 높은 다른 인터럽트가 아닌 경우, IE(0xFFFF)를 검사하여 해당 인터럽트 비트가 1로 설정되어 있는지 확인하여 특정 인터럽트의 서비스를 허용합니다.
~~~
1번은 EI 및 DI CPU 명령어에 의해 각각 true와 false로 설정됩니다. 2번 또는 3번이 모두 거짓이면, 인터럽트는 2와 3이 모두 참일 때까지 계속 대기하며, 게임은 해당 인터럽트 비트를 IF(0xFF0F)로 재설정하여 인터럽트 요청을 해제하지 않습니다.
## Gameboy Interrupts:
인터럽트는 IE 및 IF 레지스터에 해당 비트가 있습니다. 또한, 에뮬레이트할 게임 보이 인터럽트 4개가 있습니다. 아래는 IE 및 IF 레지스터의 인터럽트 목록과 해당 비트가 있습니다.
~~~
Bit 0: V-Blank Interrupt
Bit 1: LCD Interrupt
Bit 2: Timer Interrupt
Bit 3: Joypad Interrupt
~~~
이것은 또한 인터럽트의 우선 순위 목록입니다. 비트가 낮을수록 우선 순위가 높은 우선 순위를 가지므로 V-Blank는 우선 순위가 가장 높습니다. 이 인터럽트와 다른 인터럽트가 모두 IF 레지스터에서 요청된 경우, V-Blank가 먼저 서비스됩니다. 인터럽트에 대한 설명은 다음과 같습니다:

**V-BLANK:** 게임 보이는 디스플레이에 한 번에 스캔 라인을 그립니다. 디스플레이에는 144개의 스캔 라인이 있으며, 마지막 스캔 라인을 그리면 처음부터 다시 시작됩니다. 스캔 라인 144 그리기를 중지하고 스캔 라인 0에서 다시 시작하는 데 걸리는 시간은 수직 공백 기간이며, 이때 V-Blank 인터럽트를 요청합니다. V-Blank 동안 게임은 이전에 제한되었던 메모리, 주로 비디오 메모리에서 게임을 읽을 수 있기 때문에 정확하게 에뮬레이션해야 하는 가장 중요한 인터럽트입니다. 게임 보이는 초당 60 프레임의 수직 새로 고침 빈도를 가지고 있습니다. 즉, 위의 2번과 3번이 항상 참이면 초당 60 V-Blank 인터럽트가 있어야 합니다. V-Blank를 정확하게 에뮬레이션하고 있는지 확인하기 위해 이것을 모니터링할 것입니다.

**LCD:** LCD 인터럽트에 대해 알아야 할 주요 정보는 게임이 특정 메모리 영역의 상태에 따라 LCD의 상태를 제한하는 것입니다. 이 게임은 또한 "활성 스캐닝 라인이 X일 때 알려달라"는 의미의 일치 변수를 설정할 수 있습니다. V-Blank가 발생할 때마다 LCD 인터럽트를 요청할 수 있습니다. V-Blank 인터럽트가 두 개(위의 V-Blank 인터럽트와 LCD 인터럽트에 내포된 V-Blank 인터럽트) 있는 이유는 모르겠으나, 기억해야 할 것은 V-Blank 동안 게임에서 허용하면, 두 개의 V-Blank 인터럽트가 요청된다는 것입니다. 첫 번째는 주 V-Blank 인터럽트이고, 두 번째는 LCD 인터럽트입니다. 그러나, 첫 번째 V-Blank 인터럽트가 우선 순위가 높습니다.

**TIMER:** 기본적으로 게임 보이 타이머는 동적 주파수에서 카운트 업하고 값이 255에 도달하고 오버플로가 발생하면 타이머 인터럽트를 요청하여 게임에 알립니다.

**JOYPAD:** 이 인터럽트는 버튼 중 하나가 눌릴 때마다 요청됩니다.

## Requesting an Interrupt:
인터럽트를 요청해야 하는 이벤트가 발생할 때마다 IF를 호출하고 요청하려는 인터럽트의 인터럽트 식별자 비트(위 표 참조)를 전달합니다. 이 함수의 구현은 다음과 같습니다:
~~~c++
void Emulator::RequestInterrupt(int id)
{
    BYTE req = ReadMemory(0xFF0F);
    req = BitSet(req, id);
    WriteMemory(0xFF0F, id);
}
~~~

## Checking the Interrupts:
Getting Started 장의 메인 에뮬레이터 업데이트 루프에서 opcode 이후 DoInterrupts() 함수에 주목해야 합니다. 이 함수는 먼저 마스터 인터럽트 스위치가 true로 설정되어 있는지 확인하고 작동합니다. 그런 다음 인터럽트 요청 플래그에 보류 중인 인터럽트가 있는지 확인합니다. 있으면 우선 순위에 따라 모든 인터럽트를 검사하여 요청 여부를 확인합니다. 요청되는 경우 IE 레지스터에서 이 특정 인터럽트가 활성화되어 있는지 확인하고, 그렇다면 서비스를 제공하고 그렇지 않은 경우 우선 순위가 낮은 인터럽트를 점검합니다.
~~~c++
void Emulator::DoInterrupts()
{
    if (m_InterruptMaster == true)
    {
        BYTE req = ReadMemory(0xFF0F);
        BYTE req = ReadMemory(0xFF0F);

        if (req > 0)
            for (int i = 0; i < 5; i++)
                if (TestBit(req, i) == true)
                    if (TestBit(enabled, i))
                        ServiceInterrupt(i);
    }
}
~~~

## Servicing the Interrupts:
먼저 마스터 인터럽트 활성화 스위치가 false로 설정되고 IF 레지스터의 해당 비트가 설정 해제됩니다. 각각의 인터럽트는 게임 메모리에 특정한 인터럽트 서비스 루틴을 가지고 있으며, 이 루틴은 프로그램 카운터가 설정되고 거기서부터 실행을 계속합니다. 인터럽트가 서비스를 완료하면 프로그램 카운터가 현재 있던 위치로 복원되고 게임 실행이 계속됩니다. 다음은 4개의 인터럽트 각각에 대한 인터럽트 서비스 루틴의 위치입니다.
~~~
V-Blank: 0x40
LCD: 0x48
TIMER: 0x50
JOYPAD: 0x60 
~~~
이것을 바탕으로 ServiceInterrupt() 함수를 다음과 같이 작성할 수 있습니다:
~~~c++
void Emulator::ServiceInterrupt(int interrupt)
{
    m_InterruptMaster = false;
    BYTE req = ReadMemory(0xFF0F);
    req = BitReset(req,interrupt);
    WriteMemory(0xFF0F,req);

// 스택에 푸시하여 현재 실행 주소를 저장해야 합니다.
    stack.push(m_ProgramCounter);

    switch (interrupt)
    {
        case 0: m_ProgramCounter = 0x40 ; break ;
        case 1: m_ProgramCounter = 0x48 ; break ;
        case 2: m_ProgramCounter = 0x50 ; break ;
        case 4: m_ProgramCounter = 0x60 ; break ; 
    }
}
~~~

## Nested Interrupts:
인터럽트 중 하나를 서비스하는 동안 인터럽트가 마스터 인터럽트 스위치를 다시 활성화할 수 있습니다. 이렇게 하면 현재 인터럽트가 다른 인터럽트에 의해 자체적으로 다운될 수 있으며, 새로운 인터럽트가 서비스를 마치면 계속해서 자체 인터럽트를 끝낼 것입니다. 디버그 로그를 살펴보고 다른 서비스를 완료하기 전에 하나의 인터럽트를 서비스하는지 확인하는 것이 유용합니다.